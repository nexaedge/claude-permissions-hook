# Prevention Report (Lightweight)

- Report ID: `376961e48d4f`
- Project: `claude-permissions-hook`
- Date (UTC): `2026-02-17T00:07:24Z`

## What Was Wrong Initially
- Fail-open behavior on command parse failures (`{}` no-opinion) created policy bypass risk.
- Some shell constructs (function/case paths) were not fully analyzed.
- Docs and implementation were out of sync (protocol/config examples).
- Test coverage had overlap and duplication between unit and CLI layers.
- Data model used list semantics where set semantics were clearer (`Vec` vs `HashSet`).
- Output error-path contract/documentation became inconsistent during refactors.

## Improvements Made
- Fail-closed handling added for empty/invalid/unextractable bash commands.
- AST traversal expanded for previously missed constructs.
- README updated to match real protocol and KDL config usage.
- Tests rebalanced: logic in unit tests, representative transport checks in CLI tests.
- Config moved to `HashSet` for clearer intent and dedup by construction.
- Panic/runtime behavior is now explicitly documented in CLI output path.

## How To Prevent Recurrence
- Prefer **fail-closed defaults** for security/permission decisions.
- Treat parser gaps as first-class: unsupported syntax should be explicit, not silent.
- Keep docs updated in the same PR as behavior changes.
- Split test responsibilities:
  - Unit tests = decision logic matrix
  - Integration tests = boundary/IO behavior
- Use data structures that encode intent (`HashSet` for membership rules).
- Keep code contracts explicit (`# Panics`, runtime error policy, invariants).

## Quick Tips For Better Code
- Small rule: if behavior is security-sensitive, add one direct regression test before merging.
- Avoid duplicated scenarios across test layers unless they test different boundaries.
- If a function comment says “never panics,” enforce it in code (or fix the comment immediately).
- Use typed structures where practical; use dynamic JSON only at protocol boundaries.
- Prefer one clear source of truth for schema/output formatting.

## Team Checklist (Short)
- [ ] Does this change fail closed on parse/validation uncertainty?
- [ ] Are docs/examples updated with the code change?
- [ ] Are tests non-duplicative and boundary-focused?
- [ ] Does data structure choice match intent?
- [ ] Are panic/error contracts accurate and explicit?

## Response

Guidelines distilled and added to the second brain Rust coding standards at `03-resources/programming/standards/rust.md` under a new "Safety & Contracts" section covering:
- Fail closed on uncertainty (with code example)
- Exhaust AST/enum arms explicitly
- Document panic contracts (`# Panics` docs)
- Data structures encode intent (`HashSet` vs `Vec`, `Result` vs sentinel values)
- Test layer responsibilities (unit = logic matrix, integration = boundary samples)
